# win_xp_2k3_heap_exploit
![alt tag](jheap.png)
bibliography
============

Waisman, Nicolas. 2007. Understanding and bypassing Windows Heap Protection. SyScan 2007,
http://www.immunityinc.com/downloads/Heap_Singapore_Jun_2007.pdf

Moore, Brett. 2008. Heaps About Heaps. SyScan 2008,
http://www.insomniasec.com/publications/Heaps_About_Heaps.ppt

McDonald, John & Valasek, Chris. Practical Windows XP/2003 Heap Exploitation. BlackHat 2009,
https://www.blackhat.com/presentations/bh-usa-09/MCDONALD/BHUSA09-McDonald-WindowsHeap-PAPER.pdf

Seeley, Steven. Heap Overflows for Humans. Net-Ninja 2012,                                 
https://net-ninja.net/article/2012/Jan/05/heap-overflows-for-humans-103

compilation
===========
gcc j.c

technique
=========
A chunk exists in FreeList and the attacker corrupts its size and allocates a new chunk of the previous size
By setting an specific size the attacker can modify a bit in RtlCommit pointer to have the location of shellcode which will be executed on heap extension

explanation
===========
The size corruption in FreeList chunks will trigger the Bitmap Flipping Technique (discovered by Waisman and extended by McDonald & Valasek)
"Lastly is the issue of the code not checking if the heap chunkâ€™s size is less than 0x80.
This can result in the attacker specifying a size greater than 0x80, hence toggling bits
at a semi-arbitrary location past the FreeListInUseBitmap on the Heap Base. This is
limited by the width of the size (SHORT) and the operation on that size. Essentially
this means that we can toggle any of the bits from 0x150158 to 0x152157. "
A minimal attack would consist on the attacker overflowing a FreeList chunk size to be 0x2138 and performing a heapspray so 0x01000000 contains shellcode which is the provided PoC
